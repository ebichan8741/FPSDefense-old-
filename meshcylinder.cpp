//================================================================================================
//
// メッシュシリンダー [meshcylinder.cpp]
// Author : TAKUYA EBIHARA
//
//================================================================================================
#include "main.h"
#include "manager.h"
#include "renderer.h"
#include "scene.h"
#include "meshcylinder.h"
#include "camera.h"

//=================================================================================================
// 定数定義
//=================================================================================================
#define CYLINDER_TEXTURENAME "data/TEXTURE/cylinder.jpg"
#define CYLINDER_MAX_U      (12)    //Ｕ方向の分割数
#define CYLINDER_HEIGHT     (150.0f) //シリンダーの高さ
#define CYLINDER_RADIUS     (500.0f) //シリンダーの半径

//=================================================================================================
// グローバル変数
//=================================================================================================
D3DXVECTOR3 g_cylinderPos;

//*************************************************************************************************
// コンストラクタ
//*************************************************************************************************
CMeshCylinder::CMeshCylinder(int nPriolity) :CScene(nPriolity)
{
}

//*************************************************************************************************
// ポリゴン初期化処理
//*************************************************************************************************
HRESULT CMeshCylinder::Init(void)
{
    //---------------------------------------------------------------------------------------------
    // 変数宣言開始
    //---------------------------------------------------------------------------------------------
    LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();
    //---------------------------------------------------------------------------------------------
    // 変数宣言終了
    //---------------------------------------------------------------------------------------------

    //頂点情報の設定
    if(FAILED(MakeVertex(pDevice)))
    {
        return E_FAIL;
    }

    //頂点インデックスの設定
    if(FAILED(MakeIndex(pDevice)))
    {
        return E_FAIL;
    }

    //ハードディスクからテクスチャを読み込む
    if(FAILED(D3DXCreateTextureFromFile(pDevice,CYLINDER_TEXTURENAME,&m_pTexture)))
    {
        //エラー時
        MessageBox(NULL,"テクスチャの読み込みに失敗しました","終了メッセージ",MB_OK);
    }

    return 0;
}

//*************************************************************************************************
// 終了処理
//*************************************************************************************************
void CMeshCylinder::Uninit(void)
{
    if( m_pTexture != NULL )
    {
        m_pTexture -> Release();        //Direct3Dデバイスの解放
        m_pTexture = NULL;
    }

    if( m_pVtxBuff != NULL )
    {
        m_pVtxBuff -> Release();            //Direct3Dインターフェースの解放
        m_pVtxBuff = NULL;
    }

    if( m_pIdxBuff != NULL )
    {
        m_pIdxBuff -> Release();            //Direct3Dインターフェースの解放
        m_pIdxBuff = NULL;
    }
}

//*************************************************************************************************
// 更新処理
//*************************************************************************************************
void CMeshCylinder::Update(void)
{

}

//*************************************************************************************************
// 描画処理
//*************************************************************************************************
void CMeshCylinder::Draw(void)
{
    //---------------------------------------------------------------------------------------------
    // 変数宣言開始
    //---------------------------------------------------------------------------------------------
    LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();
    D3DXMATRIX mtxWorld;
    int nNumVtx,nNumFace;
    //---------------------------------------------------------------------------------------------
    // 変数宣言終了
    //---------------------------------------------------------------------------------------------

    pDevice->SetStreamSource(
        0,                        //ストリーム番号(パイプ番号)
        m_pVtxBuff,       //ストリームの元になる頂点バッファ
        0,                        //オフセット(バイト)
        sizeof(VERTEX_3D));       //一個の頂点データのサイズ(ストライド量)

    //デバイスにインデックスバッファの設定
    pDevice->SetIndices(m_pIdxBuff);

    //頂点フォーマットの設定
    pDevice -> SetFVF(FVF_VERTEX_3D);

    //テクスチャの設定
    pDevice->SetTexture(0,m_pTexture);

    //ライトのオフ
    pDevice->SetRenderState(D3DRS_LIGHTING,FALSE);

    //ワールド座標変換行列
    D3DXMatrixIdentity(&mtxWorld);            //ワールド座標変換行列を初期化

    pDevice->SetTransform(D3DTS_WORLD,&mtxWorld);        //ワールド座標変換行列を移動できるようにする(?)

    //頂点数とプリミティブ数の計算
    nNumVtx = (CYLINDER_MAX_U + 1) * 2;
    nNumFace = (CYLINDER_MAX_U + 1) * 2;

    //インデックスバッファによる描画
    pDevice->DrawIndexedPrimitive(
        D3DPT_TRIANGLESTRIP,        //描画形式
        0,                          //最初の頂点インデックスまでのオフセット
        0,                          //最小の頂点インデックス
        nNumVtx,                    //頂点数
        0,                          //スタートインデックス
        nNumFace);                  //プリミティブ数

    //ライトのオン
    pDevice->SetRenderState(D3DRS_LIGHTING,TRUE);
}

//*************************************************************************************************
// 頂点情報の設定
//*************************************************************************************************
HRESULT CMeshCylinder::MakeVertex(LPDIRECT3DDEVICE9 pDevice)
{
    //---------------------------------------------------------------------------------------------
    // 変数宣言開始
    //---------------------------------------------------------------------------------------------
    VERTEX_3D* pVtx;
    D3DXVECTOR3 pos[(CYLINDER_MAX_U + 1) * 2];
    int nNumVtx;
    //---------------------------------------------------------------------------------------------
    // 変数宣言終了
    //---------------------------------------------------------------------------------------------

    //頂点数の計算
    nNumVtx = (CYLINDER_MAX_U + 1) * 2;

    //頂点バッファ
    if(FAILED(pDevice->CreateVertexBuffer(
        sizeof(VERTEX_3D) * nNumVtx,    //作成したい頂点バッファのサイズ
        D3DUSAGE_WRITEONLY,             //使用方法
        FVF_VERTEX_3D,                  //次元設定
        D3DPOOL_MANAGED,                //メモリ管理方法(デバイスにお任せ)
        &m_pVtxBuff,
        NULL)))
    {
        return E_FAIL;
    }

    //頂点情報の設定///////////////////////////////////////////////////////////////////////////////
    m_pVtxBuff->Lock(0,0,(void**)&pVtx,0);    //ロック

    //頂点座標
    for(int i = 0;i < 2;i++)
    {
        for(int j = 0;j < CYLINDER_MAX_U + 1;j++)
        {
            //頂点座標計算
            pVtx[i * (CYLINDER_MAX_U + 1) + j].pos = D3DXVECTOR3(
                CYLINDER_RADIUS * cosf(D3DX_PI * j / (CYLINDER_MAX_U / 2) * -1),          //X
                CYLINDER_HEIGHT - i * CYLINDER_HEIGHT,                                    //Y
                CYLINDER_RADIUS * sinf(D3DX_PI * j / (CYLINDER_MAX_U / 2) * -1));         //Z

            //デバック用
            pos[i * (CYLINDER_MAX_U + 1) + j] = D3DXVECTOR3(
                CYLINDER_RADIUS * cosf(D3DX_PI * j / (CYLINDER_MAX_U / 2)),          //X
                CYLINDER_HEIGHT - i * CYLINDER_HEIGHT,                               //Y
                CYLINDER_RADIUS * sinf(D3DX_PI * j / (CYLINDER_MAX_U / 2)));         //Z

            pVtx[i * (CYLINDER_MAX_U + 1) + j].normal = D3DXVECTOR3(0.0f,0.0f,1.0f);
            pVtx[i * (CYLINDER_MAX_U + 1) + j].color = D3DCOLOR_RGBA(255, 255, 255, 255);
            pVtx[i * (CYLINDER_MAX_U + 1) + j].tex = D3DXVECTOR2(j * (1.0 / CYLINDER_MAX_U), i * 1.0f);
        }
    }

    m_pVtxBuff->Unlock();    //アンロック

    return 0;
}

//*************************************************************************************************
// 頂点インデックスの設定
//*************************************************************************************************
HRESULT CMeshCylinder::MakeIndex(LPDIRECT3DDEVICE9 pDevice)
{
    //---------------------------------------------------------------------------------------------
    // 変数宣言開始
    //---------------------------------------------------------------------------------------------
    WORD* pIdx;
    WORD wIdx[(CYLINDER_MAX_U + 1) * 2];
    int nNumIdx;
    //---------------------------------------------------------------------------------------------
    // 変数宣言終了
    //---------------------------------------------------------------------------------------------

    //インデックス数の計算
    nNumIdx = (CYLINDER_MAX_U + 1) * 2;

    //インデックスバッファ
    if(FAILED(pDevice->CreateIndexBuffer(
        sizeof(WORD) * nNumIdx,             //インデックス数
        D3DUSAGE_WRITEONLY,                 //使用用途フラグ
        D3DFMT_INDEX16,                     //インデックスデータのフォーマット
        D3DPOOL_MANAGED,                    //メモリの管理方法（お任せ）
        &m_pIdxBuff,              //インデックスバッファポインタのアドレス
        NULL)));

    //頂点インデックスの設定////////////////////////////////////////////////////////////////////////
    m_pIdxBuff->Lock(0,0,(void**)&pIdx,0);    //ロック

    //N字型に生成
    //横のメッシュ生成
    for(int i = 0;i < CYLINDER_MAX_U + 1;i++)
    {
        pIdx[i * 2] = i + (CYLINDER_MAX_U + 1);
        pIdx[i * 2 + 1] = i;
            
        //デバック用
        wIdx[i * 2] = i + (CYLINDER_MAX_U + 1);
        wIdx[i * 2 + 1] = i;
    }

    m_pIdxBuff->Unlock();    //アンロック
    return 0;
}

//*************************************************************************************************
// インスタンス生成
//*************************************************************************************************
CMeshCylinder *CMeshCylinder::Create(void)
{
    CMeshCylinder *meshCylinder;

    meshCylinder = new CMeshCylinder(PRIOLITY_0);

    meshCylinder->Init();

    return meshCylinder;
}
